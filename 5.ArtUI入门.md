5.ArtUI入门
===

方舟开发框架（ArkUI）概述
方舟开发框架（简称ArkUI）为OpenHarmony应用的UI开发提供了完整的基础设施，包括简洁的UI语法、丰富的UI功能（组件、布局、动画以及交互事件），以及实时界面预览工具等，可以支持开发者进行可视化界面开发。

基本概念
- UI： 即用户界面。开发者可以将应用的用户界面设计为多个功能页面，每个页面进行单独的文件管理，并通过页面路由API完成页面间的调度管理如跳转、回退等操作，以实现应用内的功能解耦。

- 组件： UI构建与显示的最小单位，如列表、网格、按钮、单选框、进度条、文本等。开发者通过多种组件的组合，构建出满足自身应用诉求的完整界面。





### 声明式UI描述
ArkTS以声明方式组合和扩展组件来描述应用程序的UI，同时还提供了基本的属性、事件和子组件配置方法，帮助开发者实现应用交互逻辑。

#### 创建组件
根据组件构造方法的不同，创建组件包含有参数和无参数两种方式。

说明：

创建组件时不需要new运算符。

##### 无参数
如果组件的接口定义没有包含必选构造参数，则组件后面的“()”不需要配置任何内容。例如，Divider组件不包含构造参数：
```TypeScript
Column() {
  Text('item 1')
  Divider()
  Text('item 2')
}
```


##### 有参数
如果组件的接口定义包含构造参数，则在组件后面的“()”配置相应参数。


### 图片显示

`Image(src: string|PixelMap|Resource`

- string格式，通常用来加载网络图片，需要申请网络访问权限
```TypeScript
Image('https://xxx.png')
```
权限的配置为app-entry-src-main目录中的module.json5文件:  

```json
    "requestPermissions": [
      {
        "name" : "ohos.permission.INTERNET",
      }
    ]
```

- PixelMap格式，可以加载像素图，常用在图片编辑中
```TypeScript
Image(pixelMapObject)
```
- Resource格式，加载本地图片
```TypeScript
// 加载app项目resource目录下media文件夹中的图片
Image($r('app.media.xxx'))
// 加载resource目录下rawfile总的图片，注意要带后缀
Image($rawfile('xxx.png'))
```


### 文本显示

```TypeScript
// 使用字符
Text('xxx')

// 使用string.json文件中的配置
Text($r('app.string.xxx'))
```

### 文本输入框

```TypeScript
TextInput(placeHolder: '占位字符', text: '当前内容')
.type(InputType.Password)
.onChange((value: string) => {

})
```

### 占位组件

Blank() 可以将布局内剩余的空间给占满 

### 按钮组件
```TypeScript
// 添加按钮，以响应用户点击
Button('戳我')
  .type(ButtonType.Capsule) // 按钮风格： 胶囊型按钮（圆角默认为高度的一半）
  .margin({
    // 距离上一个的高度
    top: 20
  })
  .onClick(() => {
    router.pushUrl({ url: 'pages/Second' }).then(() => {
      console.info('start second page')
    })
  })
  .backgroundColor('#0D9FFB')
  .width('40%')
  .height('5%')
```

### 滑动条属性

```TypeScript
 Slider({
      min: 0,
      max: 100,
      value: 30,
      step: 10,
      style: SliderStyle.OutSet, // 滑块在进度条内还是上
      direction: Axis.Horizontal,
      reverse: false
    }).showTips(true) // 滑动时气泡显示进度
      .showSteps(true) // 显示步长
      .blockColor('#f00')
      .trackThickness(8) // 滑动条的粗细
      .width('100%')
      .onChange((value: number, mode: SliderChangeMode) => {

      })
```


### 线性布局（Row/Column）

线性布局（LinearLayout）是开发中最常用的布局，通过线性容器Row和Column构建。线性布局是其他布局的基础，其子元素在线性方向上（水平方向和垂直方向）依次排列。线性布局的排列方向由所选容器组件决定，Column容器内子元素按照垂直方向排列，Row容器内子元素按照水平方向排列。根据不同的排列方向，开发者可选择使用Row或Column容器创建线性布局。

在布局容器内，可以通过space属性设置排列方向上子元素的间距，使各子元素在排列方向上有等间距效果。
就是Android的LinearLayout

```TypeScript
Column({ space: 20 }) {
  Text('space: 20').fontSize(15).fontColor(Color.Gray).width('90%')
  Row().width('90%').height(50).backgroundColor(0xF5DEB3)
  Row().width('90%').height(50).backgroundColor(0xD2B48C)
  Row().width('90%').height(50).backgroundColor(0xF5DEB3)
}.width('100%')

```

![image](https://github.com/CharonChui/Pictures/blob/master/colum_row_1.png?raw=true)

- 主轴： 当前空间排列方向的轴
- 交叉轴： 与主轴垂直的轴

对齐方式:    
- justifyContent: 设置子元素在主轴方向的对齐方式， 参数是FlexAlign的枚举
- alignItems: 设置子元素在交叉轴方向的对齐方式， Row容器使用VerticalAlign枚举，Column容器使用HorizontalAlign枚举

#### justifyContent

在布局容器内，可以通过justifyContent属性设置子元素在容器主轴上的排列方式。可以从主轴起始位置开始排布，也可以从主轴结束位置开始排布，或者均匀分割主轴的空间。

![image](https://github.com/CharonChui/Pictures/blob/master/column_justcontent_1.png?raw=true)

Row和Column的方向不同，方式都是一样的

#### alignItems

![image](https://github.com/CharonChui/Pictures/blob/master/alignitems_1.png?raw=true)

### 间距

和Android的基本一样。

- 外边距: margin
- 内边距: padding




### 层叠布局（Stack）

层叠布局（StackLayout）用于在屏幕上预留一块区域来显示组件中的元素，提供元素可以重叠的布局。      


层叠布局通过Stack容器组件实现位置的固定定位与层叠，容器中的子元素依次入栈，后一个子元素覆盖前一个子元素，子元素可以叠加，也可以设置位置。

层叠布局具有较强的页面层叠、位置定位能力，其使用场景有广告、卡片层叠效果等。
这有点类似Android中的FrameLayout


### 弹性布局（Flex）

弹性布局（Flex）提供更加有效的方式对容器中的子元素进行排列、对齐和分配剩余空间。常用于页面头部导航栏的均匀分布、页面框架的搭建、多行数据的排列等。

容器默认存在主轴与交叉轴，子元素默认沿主轴排列，子元素在主轴方向的尺寸称为主轴尺寸，在交叉轴方向的尺寸称为交叉轴尺寸。


### 相对布局（RelativeContainer）

RelativeContainer为采用相对布局的容器，支持容器内部的子元素设置相对位置关系。子元素支持指定兄弟元素作为锚点，也支持指定父容器作为锚点，基于锚点做相对位置布局。

```TypeScript
@Entry
@Component
struct Index {
  build() {
    Row() {
      RelativeContainer() {
        Row()
          .width(100)
          .height(100)
          .backgroundColor('#FF3333')
          .alignRules({
            top: { anchor: '__container__', align: VerticalAlign.Top },  //以父容器为锚点，竖直方向顶头对齐
            middle: { anchor: '__container__', align: HorizontalAlign.Center }  //以父容器为锚点，水平方向居中对齐
          })
          .id('row1')  //设置锚点为row1

        Row() {
          Image($r('app.media.icon'))
        }
        .height(100).width(100)
        .alignRules({
          top: { anchor: 'row1', align: VerticalAlign.Bottom },  //以row1组件为锚点，竖直方向低端对齐
          left: { anchor: 'row1', align: HorizontalAlign.Start }  //以row1组件为锚点，水平方向开头对齐
        })
        .id('row2')  //设置锚点为row2

        Row()
          .width(100)
          .height(100)
          .backgroundColor('#FFCC00')
          .alignRules({
            top: { anchor: 'row2', align: VerticalAlign.Top }
          })
          .id('row3')  //设置锚点为row3

        Row()
          .width(100)
          .height(100)
          .backgroundColor('#FF9966')
          .alignRules({
            top: { anchor: 'row2', align: VerticalAlign.Top },
            left: { anchor: 'row2', align: HorizontalAlign.End },
          })
          .id('row4')  //设置锚点为row4

        Row()
          .width(100)
          .height(100)
          .backgroundColor('#FF66FF')
          .alignRules({
            top: { anchor: 'row2', align: VerticalAlign.Bottom },
            middle: { anchor: 'row2', align: HorizontalAlign.Center }
          })
          .id('row5')  //设置锚点为row5
      }
      .width(300).height(300)
      .border({ width: 2, color: '#6699FF' })
    }
    .height('100%').margin({ left: 30 })
  }
}
```



### 栅格布局（GridRow/GridCol）

栅格布局是一种通用的辅助定位工具，对移动设备的界面设计有较好的借鉴作用。主要优势包括：

提供可循的规律：栅格布局可以为布局提供规律性的结构，解决多尺寸多设备的动态布局问题。通过将页面划分为等宽的列数和行数，可以方便地对页面元素进行定位和排版。

统一的定位标注：栅格布局可以为系统提供一种统一的定位标注，保证不同设备上各个模块的布局一致性。这可以减少设计和开发的复杂度，提高工作效率。

灵活的间距调整方法：栅格布局可以提供一种灵活的间距调整方法，满足特殊场景布局调整的需求。通过调整列与列之间和行与行之间的间距，可以控制整个页面的排版效果。

自动换行和自适应：栅格布局可以完成一对多布局的自动换行和自适应。当页面元素的数量超出了一行或一列的容量时，他们会自动换到下一行或下一列，并且在不同的设备上自适应排版，使得页面布局更加灵活和适应性强。

GridRow为栅格容器组件，需与栅格子组件GridCol在栅格布局场景中联合使用。




### 创建列表（List）

列表是一种复杂的容器，当列表项达到一定数量，内容超过屏幕大小时，可以自动提供滚动功能。它适合用于呈现同类数据类型或数据类型集，例如图片和文本。      

在列表中显示数据集合是许多应用程序中的常见要求（如通讯录、音乐列表、购物清单等）。

使用列表可以轻松高效地显示结构化、可滚动的信息。        

通过在List组件中按垂直或者水平方向线性排列子组件ListItemGroup或ListItem，为列表中的行或列提供单个视图，或使用循环渲染迭代一组行或列，或混合任意数量的单个视图和ForEach结构，构建一个列表。      

List组件支持使用条件渲染、循环渲染、懒加载等渲染控制方式生成子组件。

类似Android的ListView。 



```TypeScript
List({space: 10}) {
  ForEach([1, 2, 3, 4], item => {
    ListItem() {
      // 列表项内容，只能包含一个根组件
      Text('item')
    }
  })
}
.width('100%')
```


### 循环渲染

ForEach,这里的渲染循环并不是前面语法说的for循环



```TypeScript 
ForEach (
    arr: Array,        // 1.要遍历的数据数组
    (item: any, index?: number) => {   // 2.页面组件生成函数

      Row() {
        Image(item.image)
        Column() {
          Text(item.name)
          Text(item.price)
        }
      }

    }),
    keyGenerator?: (item: any, index?: number): string => {  // 3.键生成函数，为数组每一项生成一个唯一标识，组件是否重新渲染的判断标准

    }
)
```


### 创建网格（Grid/GridItem）

网格布局是由“行”和“列”分割的单元格所组成，通过指定“项目”所在的单元格做出各种各样的布局。网格布局具有较强的页面均分能力，子组件占比控制能力，是一种重要自适应布局，其使用场景有九宫格图片展示、日历、计算器等。

ArkUI提供了Grid容器组件和子组件GridItem，用于构建网格布局。Grid用于设置网格布局相关参数，GridItem定义子组件相关特征。Grid组件支持使用条件渲染、循环渲染、懒加载等方式生成子组件。



### 创建网格（Grid/GridItem）

网格布局是由“行”和“列”分割的单元格所组成，通过指定“项目”所在的单元格做出各种各样的布局。网格布局具有较强的页面均分能力，子组件占比控制能力，是一种重要自适应布局，其使用场景有九宫格图片展示、日历、计算器等。

ArkUI提供了Grid容器组件和子组件GridItem，用于构建网格布局。Grid用于设置网格布局相关参数，GridItem定义子组件相关特征。Grid组件支持使用条件渲染、循环渲染、懒加载等方式生成子组件。


### 创建轮播（Swiper）
Swiper组件提供滑动轮播显示的能力。Swiper本身是一个容器组件，当设置了多个子组件后，可以对这些子组件进行轮播显示。通常，在一些应用首页显示推荐的内容时，需要用到轮播显示的能力。

#### 布局与约束
Swiper作为一个容器组件，在自身尺寸属性未被设置时，会自动根据子组件的大小设置自身的尺寸。如果开发者对Swiper组件设置了固定的尺寸，则在轮播显示过程中均以该尺寸生效；否则，在轮播过程中，会根据子组件的大小自动调整自身的尺寸。


### 页面和自定义组件生命周期
在开始之前，我们先明确自定义组件和页面的关系：

自定义组件：@Component装饰的UI单元，可以组合多个系统组件实现UI的复用。

页面：即应用的UI页面。可以由一个或者多个自定义组件组成，@Entry装饰的自定义组件为页面的入口组件，即页面的根节点，一个页面有且仅能有一个@Entry。只有被@Entry装饰的组件才可以调用页面的生命周期。

页面生命周期，即被@Entry装饰的组件生命周期，提供以下生命周期接口：

- onPageShow：页面每次显示时触发。

- onPageHide：页面每次隐藏时触发一次。

- onBackPress：当用户点击返回按钮时触发。

组件生命周期，即一般用@Component装饰的自定义组件的生命周期，提供以下生命周期接口：

- aboutToAppear：组件即将出现时回调该接口，具体时机为在创建自定义组件的新实例后，在执行其build()函数之前执行。

- aboutToDisappear：在自定义组件即将析构销毁时执行。

生命周期流程如下图所示，下图展示的是被@Entry装饰的组件（首页）生命周期。

![image](https://github.com/CharonChui/Pictures/blob/master/zh-cn_image_0000001502372786.png?raw=true)

```TypeScript
@Component
struct Child {
  @State title: string = 'Hello World';
  // 组件生命周期
  aboutToDisappear() {
    console.info('[lifeCycle] Child aboutToDisappear')
  }
  // 组件生命周期
  aboutToAppear() {
    console.info('[lifeCycle] Child aboutToAppear')
  }

  build() {
    Text(this.title)
    .fontSize(50)
    .onClick(() => {
      this.title = 'Hello ArkUI';
    })
  }
}
```


### 自定义组件


#### 方式1：@Component装饰器进行自定义组件抽取

##### 1.1当前组件内抽取

```TypeScript
@Entry
@Component
struct Second {
  // 注意string是小写，不是String
  @State message: string = "Hello HarmonyOS"

  build() {
    Row() {
      Column() {
        Header({content: 'haha'})
        Text(this.message)
          .fontSize(30)
          .fontWeight(FontWeight.Bold)
      }
      .width('100%')
    }
    .height('100%')
  }
}

@Component
struct Header {
  content: string
  build() {
    Text(this.content)
      .fontSize(15)
  }
}
```

##### 1.2单独文件抽取
在ets目录下新加conponents文件夹，里面新加Header.ets
```TypeScript
@Component
// 想要输出的模块，必须加上export
export struct Header {
  content: string
  build() {
    Text(this.content)
      .fontSize(15)
  }
}
```

使用:    

```TypeScript
// 需要先导入组件
import {Header} from '../components/Header'
@Entry
@Component
struct Second {
  // 注意string是小写，不是String
  @State message: string = "Hello HarmonyOS"

  build() {
    Row() {
      Column() {
        Header({content: 'haha'})
        Text(this.message)
          .fontSize(30)
          .fontWeight(FontWeight.Bold)
      }
      .width('100%')
    }
    .height('100%')
  }
}

```

#### 方式2：@Builder装饰器进行自定义构建函数
前面章节介绍了如何创建一个自定义组件。该自定义组件内部UI结构固定，仅与使用方进行数据传递。ArkUI还提供了一种更轻量的UI元素复用机制@Builder，@Builder所装饰的函数遵循build()函数语法规则，开发者可以将重复使用的UI元素抽象成一个方法，在build方法里调用。

为了简化语言，我们将@Builder装饰的函数也称为“自定义构建函数”。


##### 2.1自定义组件内自定义构建函数

在外组件struct内部定义: 
定义的语法：

```TypeScript
// 组件内的构建函数不用加function
@Builder MyBuilderFunction() { ... }
```

使用方法：
```TypeScript
// 组件内的构建函数需要使用this
this.MyBuilderFunction() { ... }
```

允许在自定义组件内定义一个或多个@Builder方法，该方法被认为是该组件的私有、特殊类型的成员函数。

自定义构建函数可以在所属组件的build方法和其他自定义构建函数中调用，但不允许在组件外调用。

在自定义函数体中，this指代当前所属组件，组件的状态变量可以在自定义构建函数内访问。建议通过this访问自定义组件的状态变量而不是参数传递。

##### 2.2全局自定义构建函数

定义在当前组件文件内，但是在当前组件struct之外
定义的语法：

```TypeScript
// 全局构建函数需要用function
@Builder function MyGlobalBuilderFunction() { ... }
```

使用方法：

```TypeScript
// 直接调用，不用this
MyGlobalBuilderFunction()
```

- 全局的自定义构建函数可以被整个应用获取，不允许使用this和bind方法。

- 如果不涉及组件状态变化，建议使用全局的自定义构建方法。

自定义构建函数的参数传递有按值传递和按引用传递两种，均需遵守以下规则：

- 参数的类型必须与参数声明的类型一致，不允许undefined、null和返回undefined、null的表达式。

- 在@Builder修饰的函数内部，不允许改变参数值。

- @Builder内UI语法遵循UI语法规则。

##### 按引用传递参数

按引用传递参数时，传递的参数可为状态变量，且状态变量的改变会引起@Builder方法内的UI刷新。ArkUI提供$$作为按引用传递参数的范式。

```TypeScript
class ABuilderParam {
  paramA1: string = ''
  paramB1: string = ''
}

@Builder function ABuilder($$ : ABuilderParam) {...}
```


```TypeScript
class ABuilderParam {
  paramA1: string = ''
}

@Builder function ABuilder($$: ABuilderParam) {
  Row() {
    Text(`UseStateVarByReference: ${$$.paramA1} `)
  }
}
@Entry
@Component
struct Parent {
  @State label: string = 'Hello';
  build() {
    Column() {
      // 在Parent组件中调用ABuilder的时候，将this.label引用传递给ABuilder
      ABuilder({ paramA1: this.label })
      Button('Click me').onClick(() => {
        // 点击“Click me”后，UI从“Hello”刷新为“ArkUI”
        this.label = 'ArkUI';
      })
    }
  }
}
```



##### 按值传递参数
调用@Builder装饰的函数默认按值传递。当传递的参数为状态变量时，状态变量的改变不会引起@Builder方法内的UI刷新。所以当使用状态变量的时候，推荐使用按引用传递。

```TypeScript
@Builder function ABuilder(paramA1: string) {
  Row() {
    Text(`UseStateVarByValue: ${paramA1} `)
  }
}
@Entry
@Component
struct Parent {
  label: string = 'Hello';
  build() {
    Column() {
      ABuilder(this.label)
    }
  }
}
```


### 自定义公共样式 

外部自定义样式：  

```TypeScript
@Entry
@Component
struct Second {
  // 注意string是小写，不是String
  @State message: string = "Hello HarmonyOS"

  build() {
    Row() {
      Column() {
        Text(this.message)
          .fillScreen();
      }
      .width('100%')
    }
    .height('100%')
  }
}

// 全局公共样式函数
@Styles function fillScreen() {
  .width('100%')
  .height('100%')
  .backgroundColor('#f00')
  .padding('20')
}
```
内部自定义样式函数，同样是去掉function:   
```TypeScript
@Entry
@Component
struct Second {
  // 注意string是小写，不是String
  @State message: string = "Hello HarmonyOS"

  @Styles fillScreen() {
    .width('100%')
    .height('100%')
    .backgroundColor('#f00')
    .padding('20')
  }

  build() {
    Row() {
      Column() {
        Text(this.message)
          .fillScreen()
      }
      .width('100%')
    }
    .height('100%')
  }
}
```

上面的属性都是所有组件通用的属性，但是如果我想对Text里面的fontSize、fontColor进行抽取呢？ 这个时候因为不是通用的，用@Style就不行了。那就要用@Extend来抽取。

#### @Extend装饰器：定义扩展组件样式

类似Kotlin的扩展函数

@Extend，用于扩展原生组件样式。

使用规则
和@Styles不同，@Extend仅支持在全局定义，不支持在组件内部定义。

和@Styles不同，@Extend支持封装指定的组件的私有属性和私有事件，以及预定义相同组件的@Extend的方法。

**注意: @Extend只能写在全局，不能写在组件内部**

```TypeScript
// @Extend(Text)可以支持Text的私有属性fontColor
@Extend(Text) function fancy () {
  .fontColor(Color.Red)
}
// superFancyText可以调用预定义的fancy
@Extend(Text) function superFancyText(size:number) {
    .fontSize(size)
    .fancy()
}
```





    
---

- 邮箱 ：charon.chui@gmail.com  
- Good Luck! 
